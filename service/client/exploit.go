package client

import (
	"0E7/service/config"
	"0E7/utils"
	"archive/tar"
	"archive/zip"
	"bufio"
	"bytes"
	"compress/gzip"
	"context"
	"crypto/md5"
	"crypto/tls"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/traefik/yaegi/interp"
	"github.com/traefik/yaegi/stdlib"
	"golang.org/x/sync/semaphore"
)

var (
	workerSemaphore *semaphore.Weighted
	jobsChan        = make(chan bool, 100)
	// downloadMutexes 用于控制同一文件的并发下载，避免重复下载
	downloadMutexes sync.Map // map[string]*sync.Mutex，key为cacheKey
	client          = &http.Client{
		Timeout: time.Duration(config.Global_timeout_http) * time.Second,
		Transport: &http.Transport{
			TLSClientConfig:       &tls.Config{InsecureSkipVerify: true},
			MaxIdleConns:          100,              // 最大空闲连接数
			MaxIdleConnsPerHost:   20,               // 每个主机的最大空闲连接数
			IdleConnTimeout:       90 * time.Second, // 空闲连接超时时间
			DisableKeepAlives:     false,            // 启用keep-alive
			DisableCompression:    false,            // 禁用压缩以减少CPU使用
			ResponseHeaderTimeout: 30 * time.Second, // 响应头超时
		},
	}
)

func exploit() {
	defer func() {
		if err := recover(); err != nil {
			log.Println("Exploit error: ", err)
		}
	}()

	values := url.Values{}
	values.Set("client_id", fmt.Sprintf("%d", config.Client_id))
	values.Set("platform", runtime.GOOS)
	values.Set("arch", runtime.GOARCH)
	request, err := http.NewRequest("GET", config.Server_url+"/api/exploit?"+values.Encode(), nil)
	if err != nil {
		log.Println(err)
		return
	}
	response, err := client.Do(request)
	if err != nil {
		log.Println(err)
		return
	}
	defer response.Body.Close() // 确保关闭响应体
	if response.StatusCode == 200 {
		jobsChan <- true
		var result map[string]interface{}
		err = json.NewDecoder(response.Body).Decode(&result)
		if err != nil {
			log.Println(err)
		}

		task_uuid := uuid.New().String()

		exploit_name := result["name"].(string)
		exploit_id_float := result["id"].(float64)
		exploit_id := int(exploit_id_float)
		client_id := config.Client_id

		log.Printf("开始执行任务 %s (ID: %d)", exploit_name, exploit_id)
		folder := "exploit/" + task_uuid + "/"
		filename := result["filename"].(string)
		command := result["command"].(string)
		environment := result["environment"].(string)
		argv := result["argv"].(string)
		flag := result["flag"].(string)
		timeoutStr := result["timeout"].(string)
		team := result["team"].(string)
		var timeout int
		if timeoutStr != "" {
			timeout, err = strconv.Atoi(timeoutStr)
			if err != nil {
				timeout = 30 // 默认30秒超时
			}
		} else {
			timeout = 30 // 默认30秒超时
		}
		output_id := ""
		exploit_output := ""

		defer func() {
			os.RemoveAll(folder)
		}()

		var code, fileType string
		match := regexp.MustCompile(`^data:(code\/(?:python2|python3|golang|bash));base64,(.*)$`).FindStringSubmatch(filename)
		if match != nil {
			_, err := os.Stat(folder)
			if err != nil {
				err = os.MkdirAll(folder, os.ModePerm)
				if err != nil {
					log.Println("IO error:", err)
					return
				}
			}
			fileType = match[1]
			data := match[2]
			switch fileType {
			case "code/python2", "code/python3":
				filename = fmt.Sprintf("%d.py", exploit_id)
			case "code/golang":
				filename = fmt.Sprintf("%d.go", exploit_id)
			case "code/bash":
				filename = fmt.Sprintf("%d.sh", exploit_id)
			}
			code_decode, err := base64.StdEncoding.DecodeString(data)
			if err != nil {
				log.Println("Base64 decode error:", err)
				return
			}
			err = ioutil.WriteFile(folder+"/"+filename, code_decode, 0644)
			if err != nil {
				log.Println("IO error:", err)
				return
			}
			code = string(code_decode)

		} else {
			err := exploit_download(fmt.Sprintf("%d", exploit_id), task_uuid, filename)
			if err != nil {
				log.Println("Download error:", err)
				return
			}
		}

		lowerStr := strings.ToLower(environment)
		_, isPipreqs := set_pipreqs.Load(fmt.Sprintf("%d", exploit_id))
		if (strings.Contains(lowerStr, "auto_pipreqs") && !isPipreqs) || strings.Contains(lowerStr, "force_pipreqs") {
			err := auto_pipreqs(folder, fileType)
			if err != nil {
				exploit_output += err.Error() + "\n"
			}
		}

		ctx_command, cancel_comand := context.WithTimeout(context.Background(), time.Duration(timeout)*time.Second)
		defer cancel_comand()

		var cmd *exec.Cmd

		var goi *interp.Interpreter
		if command == "" && strings.HasSuffix(filename, ".py") {
			args := []string{"-u", filename}
			args = append(args, splitArgs(argv)...)
			switch fileType {
			case "code/python2":
				cmd = exec.CommandContext(ctx_command, "python2", args...)
			case "code/python3":
				cmd = exec.CommandContext(ctx_command, "python3", args...)
			}
		} else if command == "" && strings.HasSuffix(filename, ".sh") {
			// 设置bash脚本执行权限
			err := os.Chmod(folder+"/"+filename, 0755)
			if err != nil {
				log.Println("设置执行权限失败:", err)
				return
			}
			args := []string{filename}
			args = append(args, splitArgs(argv)...)
			cmd = exec.CommandContext(ctx_command, "bash", args...)
		} else if command != "" {
			if runtime.GOOS == "windows" {
				args := []string{"/C", command}
				args = append(args, splitArgs(argv)...)
				cmd = exec.CommandContext(ctx_command, "cmd.exe", args...)
			} else {
				args := []string{"-c", command}
				args = append(args, splitArgs(argv)...)
				cmd = exec.CommandContext(ctx_command, "/bin/sh", args...)
			}
		} else if fileType == "code/golang" {
			cmd = nil
		} else {
			return
		}
		wddir, err := os.Getwd()
		if err != nil {
			log.Println("无法获取当前目录：", err)
			return
		}

		var stdout io.ReadCloser
		var stdeer bytes.Buffer
		var readout *bufio.Reader
		var goibuf bytes.Buffer
		var wg sync.WaitGroup
		var goierr error
		envVars := strings.Split(environment, ";")
		env := append(os.Environ(), envVars...)

		status := "RUNNING"

		if fileType == "code/golang" {
			goi = interp.New(interp.Options{Stdout: &goibuf, Stderr: &stdeer, Args: splitArgs(argv), Env: env})
			goi.Use(stdlib.Symbols)
			md5 := utils.GetMd5FromString(argv + "_" + code)
			var program *interp.Program
			if value, ok := programs.Load(md5); !ok {
				program, err = goi.Compile(code)
				if err != nil {
					log.Println("Compile error:", err.Error())
					return
				}
				programs.Store(md5, program)
			} else {
				program = value.(*interp.Program)
			}
			readout = bufio.NewReader(&goibuf)
			wg.Add(1)
			go func() {
				defer wg.Done()
				_, goierr = goi.ExecuteWithContext(ctx_command, program)
				if goierr != nil {
					log.Println("Runtime error:", goierr.Error())
					return
				}
			}()
		} else if cmd != nil {
			cmd.WaitDelay = time.Duration(timeout) * time.Second
			cmd.Dir = wddir + "/" + folder
			cmd.Env = env
			stdout, err = cmd.StdoutPipe()
			if err != nil {
				log.Println("Pipe Error:", err)
				return
			}
			cmd.Stderr = &stdeer
			readout = bufio.NewReader(stdout)
			err = cmd.Start()
			if err != nil {
				log.Println(err)
				return
			}
		} else {
			log.Println("没有可执行的命令")
			return
		}
		ctx, cancel := context.WithCancel(context.Background())
		go post_output_scanner(readout, &exploit_output)
		var wg_output sync.WaitGroup
		wg_output.Add(1)
		go post_output_status(&output_id, exploit_id, client_id, status, ctx, &wg_output, &exploit_output)

		// 等待命令完成或超时
		done := make(chan error, 1)
		go func() {
			if fileType == "code/golang" {
				wg.Wait()
				done <- goierr
			} else {
				done <- cmd.Wait()
			}
		}()

		select {
		case err := <-done:
			// 命令正常完成
			if err != nil {
				// 检查是否是超时错误
				if err == context.DeadlineExceeded {
					status = "TIMEOUT"
					log.Printf("任务 %s (ID: %d) 执行超时 (超过 %d 秒)", exploit_name, exploit_id, timeout)
				} else {
					status = "ERROR"
					log.Printf("任务 %s (ID: %d) 执行失败: %v", exploit_name, exploit_id, err)
					log.Println("错误输出:\n" + stdeer.String())
				}
			} else {
				status = "SUCCESS"
				set_pipreqs.Store(fmt.Sprintf("%d", exploit_id), true)
				log.Printf("任务 %s (ID: %d) 执行成功", exploit_name, exploit_id)
			}
		case <-ctx_command.Done():
			// 超时发生
			status = "TIMEOUT"
			log.Printf("任务 %s (ID: %d) 执行超时 (超过 %d 秒)", exploit_name, exploit_id, timeout)

			// 强制终止进程
			if cmd.Process != nil {
				cmd.Process.Kill()
			}
		}

		// 先停止后台状态更新
		cancel()
		wg_output.Wait()

		// 然后发送最终状态更新
		output_id = post_output(output_id, exploit_id, client_id, "", status)

		post_output_scanner(readout, &exploit_output)

		erroutput := stdeer.String()
		if erroutput != "" {
			if status == "TIMEOUT" {
				erroutput = "\nTIMEOUT:\n" + erroutput
			} else {
				erroutput = "\nERROR:\n" + erroutput
			}
		} else if status == "TIMEOUT" {
			erroutput = "\nTIMEOUT: " + strconv.Itoa(timeout) + " seconds"
		}

		output_id = post_output(output_id, exploit_id, client_id, exploit_output+erroutput, status)

		log.Println("RUN " + exploit_name + " OUTPUT:\n" + exploit_output)

		if flag != "" {
			regexpObj := regexp.MustCompile(flag)
			matches := regexpObj.FindAllString(exploit_output, -1)
			for _, match := range matches {
				post_flag(exploit_id, team, match)
			}
		}
	}
}

func splitArgs(input string) []string {
	var args []string
	start := -1
	inQuote := false

	for i, char := range input {
		if char == '"' {
			inQuote = !inQuote
		} else if char == ' ' && !inQuote {
			if start >= 0 {
				if input[start] == '"' && input[i-1] == '"' {
					args = append(args, input[start+1:i-1])
				} else {
					args = append(args, input[start:i])
				}
				start = -1
			}
			continue
		}

		if start < 0 {
			start = i
		}
	}

	if start >= 0 {
		if input[start] == '"' && input[len(input)-1] == '"' {
			args = append(args, input[start+1:len(input)-1])
		} else {
			args = append(args, input[start:])
		}
	}

	return args
}

func post_output_scanner(readout *bufio.Reader, exploit_output *string) {
	defer func() {
		if err := recover(); err != nil {
			log.Println("Post output scanner Error:", err)
		}
	}()
	outputBytes := make([]byte, 200)
	for {
		n, err := readout.Read(outputBytes)
		if err != nil {
			if errors.Is(err, io.EOF) || errors.Is(err, fs.ErrClosed) {
				return
			}
			log.Println(err)
			*exploit_output += err.Error()
			return
		}
		output := string(outputBytes[:n])
		*exploit_output += output
	}
}
func post_output_status(output_id *string, exploit_id int, client_id int, status string, ctx context.Context, wg_output *sync.WaitGroup, exploit_output *string) {
	defer func() {
		if err := recover(); err != nil {
			log.Println("Post output Status Error:", err)
		}
		wg_output.Done() // 确保在函数退出时调用Done()
	}()
	run := false
	old_len := 0
	for {
		select {
		case <-ctx.Done():
			return
		case <-time.After(5 * time.Second):
			new_len := len(*exploit_output)
			*output_id = post_output(*output_id, exploit_id, client_id, (*exploit_output)[old_len:new_len], status)
			old_len = new_len
			if !run {
				run = true
			}
		}
	}
}

func post_output(id string, exploit_id int, client_id int, output string, status string) string {
	values := url.Values{}
	values.Set("id", id)
	values.Set("exploit_id", fmt.Sprintf("%d", exploit_id))
	values.Set("client_id", fmt.Sprintf("%d", client_id))
	values.Set("output", output)
	values.Set("status", status)

	requestBody := bytes.NewBufferString(values.Encode())
	request, err := http.NewRequest("POST", config.Server_url+"/api/exploit_output", requestBody)
	if err != nil {
		log.Println(err)
		return ""
	}
	request.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	response, err := client.Do(request)
	if err != nil {
		log.Println(err)
		return ""
	}
	defer response.Body.Close() // 确保关闭响应体
	if response.StatusCode == http.StatusOK {
		//log.Printf("Post success")
		var result map[string]interface{}
		err = json.NewDecoder(response.Body).Decode(&result)
		if err != nil {
			log.Println(err)
		}
		return result["id"].(string)
	} else {
		log.Printf("Postfail with %d", response.StatusCode)
		return ""
	}
}

func post_flag(exploit_id int, team string, exploit_flag string) {
	values := url.Values{}
	values.Set("exploit_id", fmt.Sprintf("%d", exploit_id))
	values.Set("flag", exploit_flag)
	values.Set("team", team)
	requestBody := bytes.NewBufferString(values.Encode())
	request, err := http.NewRequest("POST", config.Server_url+"/api/flag", requestBody)
	if err != nil {
		log.Println(err)
	}
	request.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	response, err := client.Do(request)
	if err != nil {
		log.Println(err)
		return
	}
	defer response.Body.Close() // 确保关闭响应体
	switch response.StatusCode {
	case http.StatusOK:
		log.Printf("Post %s success", exploit_flag)
	case http.StatusAccepted:
		log.Printf("Post %s skipped", exploit_flag)
	default:
		respBody, err := io.ReadAll(response.Body)
		if err != nil {
			log.Println(err)
		}
		log.Printf("Post %s fail with %d: %s", exploit_flag, response.StatusCode, string(respBody))
	}
}

func auto_pipreqs(filepath string, fileType string) error {
	var pipName string
	switch fileType {
	case "code/python2":
		pipName = "pip2"
	case "code/python3":
		pipName = "pip3"
	default:
		return fmt.Errorf("not need auto pipreqs for file type %s", fileType)
	}
	cmd := exec.Command(pipName, "install", "pipreqs", "-i", config.Client_pypi, "--break")
	err := cmd.Start()
	if err != nil {
		log.Println("Auto pipreqs:", err.Error())
		return err
	}
	if err = cmd.Wait(); err != nil {
		log.Println("Auto pipreqs:", err.Error())
		return err
	}

	cmd = exec.Command("pipreqs", "--encoding=utf-8", filepath, "--savepath", filepath+"auto_pipreqs.txt", "--force", "--mode", "no-pin")

	err = cmd.Start()
	if err != nil {
		log.Println(err.Error())
		return err
	}
	if err = cmd.Wait(); err != nil {
		log.Println("Auto pipreqs:", err.Error())
		return err
	}

	cmd = exec.Command(pipName, "install", "-r", filepath+"auto_pipreqs.txt", "-i", config.Client_pypi, "--break")
	err = cmd.Start()
	if err != nil {
		log.Println(err.Error())
		return err
	}
	if err = cmd.Wait(); err != nil {
		log.Println("Auto pipreqs:", err.Error())
		return err
	}
	return nil
}

/*
	func setenv(environment string) {
		vars := strings.Split(environment, ";")
		for _, v := range vars {
			kv := strings.SplitN(v, "=", 2)
			if len(kv) == 2 {
				key := kv[0]
				value := kv[1]
				os.Setenv(key, value)
			}
		}
	}
*/
// calculateFileMD5 计算文件的MD5值
func calculateFileMD5(filePath string) (string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return "", err
	}
	defer file.Close()

	hash := md5.New()
	if _, err := io.Copy(hash, file); err != nil {
		return "", err
	}

	return hex.EncodeToString(hash.Sum(nil)), nil
}

// copyFile 复制文件
func copyFile(src, dest string) error {
	sourceFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer sourceFile.Close()

	destFile, err := os.Create(dest)
	if err != nil {
		return err
	}
	defer destFile.Close()

	_, err = io.Copy(destFile, sourceFile)
	if err != nil {
		return err
	}

	// 同步文件属性
	srcInfo, err := os.Stat(src)
	if err == nil {
		os.Chmod(dest, srcInfo.Mode())
	}

	return nil
}

// copyDir 递归复制目录
func copyDir(src, dest string) error {
	srcInfo, err := os.Stat(src)
	if err != nil {
		return err
	}

	if !srcInfo.IsDir() {
		return fmt.Errorf("source is not a directory")
	}

	err = os.MkdirAll(dest, srcInfo.Mode())
	if err != nil {
		return err
	}

	entries, err := os.ReadDir(src)
	if err != nil {
		return err
	}

	for _, entry := range entries {
		srcPath := filepath.Join(src, entry.Name())
		destPath := filepath.Join(dest, entry.Name())

		if entry.IsDir() {
			err = copyDir(srcPath, destPath)
			if err != nil {
				return err
			}
		} else {
			err = copyFile(srcPath, destPath)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func exploit_download(exploit_name string, task_uuid string, filename string) error {
	if filename == "" {
		return nil
	}

	// 生成缓存key：基于exploit_id和filename
	cacheKey := utils.GetMd5FromString(exploit_name + "_" + filename)
	cacheDir := "exploit/cache/" + cacheKey
	workDir := "exploit/" + task_uuid

	// 检查缓存是否存在
	cachedFile := filepath.Join(cacheDir, filename)
	cacheInfoFile := filepath.Join(cacheDir, ".cacheinfo")
	_, err := os.Stat(cachedFile)
	cacheExists := err == nil

	// 准备下载请求
	values := url.Values{}
	values.Set("id", exploit_name)
	values.Set("filename", filename)
	request, err := http.NewRequest("GET", config.Server_url+"/api/exploit_download?"+values.Encode(), nil)
	if err != nil {
		return err
	}

	// 先发送HEAD请求获取服务器端MD5（用于验证缓存）
	var serverMD5 string
	if cacheExists {
		headRequest, err := http.NewRequest("HEAD", config.Server_url+"/api/exploit_download?"+values.Encode(), nil)
		if err == nil {
			headResponse, err := client.Do(headRequest)
			if err == nil {
				serverMD5 = headResponse.Header.Get("X-File-MD5")
				headResponse.Body.Close()
			}
		}

		// 如果获取到服务器端MD5，验证缓存
		if serverMD5 != "" {
			cachedMD5, err := calculateFileMD5(cachedFile)
			if err == nil {
				if cachedMD5 != serverMD5 {
					log.Printf("缓存文件MD5不匹配 (缓存: %s, 服务器: %s)，删除缓存并重新下载", cachedMD5, serverMD5)
					os.Remove(cachedFile)
					os.Remove(cacheInfoFile)
					cacheExists = false
				} else {
					log.Printf("缓存文件MD5验证通过: %s", cachedMD5)
				}
			}
		}
	}

	// 如果缓存不存在或验证失败，需要下载（使用锁控制并发）
	if !cacheExists {
		// 获取或创建该文件的下载锁
		mutexInterface, _ := downloadMutexes.LoadOrStore(cacheKey, &sync.Mutex{})
		downloadMutex := mutexInterface.(*sync.Mutex)

		// 获取锁
		downloadMutex.Lock()
		defer downloadMutex.Unlock()

		// Double-check: 获取锁后再次检查缓存（可能其他goroutine已经下载完成）
		_, err = os.Stat(cachedFile)
		if err == nil {
			log.Printf("其他goroutine已完成下载，使用缓存文件: %s (cache key: %s)", cachedFile, cacheKey)
			cacheExists = true
		} else {
			// 缓存确实不存在，开始下载
			log.Printf("缓存不存在或验证失败，开始下载文件: %s (cache key: %s)", filename, cacheKey)
			response, err := client.Do(request)
			if err != nil {
				return err
			}
			defer response.Body.Close()

			// 获取服务器端MD5
			serverMD5 = response.Header.Get("X-File-MD5")

			// 确保缓存目录存在
			err = os.MkdirAll(cacheDir, os.ModePerm)
			if err != nil {
				return err
			}

			// 下载到缓存目录
			out, err := os.Create(cachedFile)
			if err != nil {
				return err
			}
			_, err = io.Copy(out, response.Body)
			out.Close()
			if err != nil {
				os.Remove(cachedFile)
				return err
			}

			// 计算下载文件的MD5并验证
			downloadedMD5, err := calculateFileMD5(cachedFile)
			if err != nil {
				os.Remove(cachedFile)
				return fmt.Errorf("计算下载文件MD5失败: %v", err)
			}

			// 验证MD5是否匹配
			if serverMD5 != "" && downloadedMD5 != serverMD5 {
				os.Remove(cachedFile)
				return fmt.Errorf("文件MD5验证失败 (下载: %s, 服务器: %s)，文件可能已损坏", downloadedMD5, serverMD5)
			}

			// 保存MD5到.cacheinfo文件
			infoFile := filepath.Join(cacheDir, ".cacheinfo")
			ioutil.WriteFile(infoFile, []byte(fmt.Sprintf("filename=%s\nmd5=%s\n", filename, downloadedMD5)), 0644)

			log.Printf("文件已下载到缓存并验证通过: %s (MD5: %s)", cachedFile, downloadedMD5)
			cacheExists = true
		}
	}

	// 使用缓存（可能是原有的或刚下载的）
	if cacheExists {
		// 读取缓存的MD5
		var cachedMD5 string
		if infoData, err := ioutil.ReadFile(cacheInfoFile); err == nil {
			// 尝试从.cacheinfo文件中解析MD5
			lines := strings.Split(string(infoData), "\n")
			for _, line := range lines {
				if strings.HasPrefix(line, "md5=") {
					cachedMD5 = strings.TrimPrefix(line, "md5=")
					break
				}
			}
		}
		if cachedMD5 == "" {
			// 如果无法从.cacheinfo读取，重新计算
			cachedMD5, _ = calculateFileMD5(cachedFile)
		}
		log.Printf("使用缓存文件: %s (MD5: %s)", cachedFile, cachedMD5)
	}

	// 确保工作目录存在
	err = os.MkdirAll(workDir, os.ModePerm)
	if err != nil {
		return err
	}

	// 复制文件到工作目录
	workFile := filepath.Join(workDir, filename)
	err = copyFile(cachedFile, workFile)
	if err != nil {
		return fmt.Errorf("复制文件到工作目录失败: %v", err)
	}

	// 如果是压缩包，需要解压
	if strings.HasSuffix(filename, ".zip") {
		err = Unzip(filename, task_uuid, workDir)
		if err != nil {
			return err
		}
	} else if strings.HasSuffix(filename, ".tar.gz") || strings.HasSuffix(filename, ".tgz") {
		err = UntarGz(filename, task_uuid, workDir)
		if err != nil {
			return err
		}
	} else if strings.HasSuffix(filename, ".tar") {
		err = Untar(filename, task_uuid, workDir)
		if err != nil {
			return err
		}
	} else if strings.HasSuffix(filename, ".gz") {
		err = Ungzip(filename, task_uuid, workDir)
		if err != nil {
			return err
		}
	}

	return nil
}
func Unzip(zipFile string, task_uuid string, workDir string) error {
	// zipFile 是文件名，完整路径在workDir中
	zipFilePath := filepath.Join(workDir, zipFile)
	r, err := zip.OpenReader(zipFilePath)
	if err != nil {
		log.Printf("解压zip失败: %v, 文件路径: %s", err, zipFilePath)
		return err
	}
	defer r.Close()
	for _, file := range r.File {
		rc, err := file.Open()
		if err != nil {
			log.Printf("打开zip内文件失败: %v", err)
			return err
		}
		path := filepath.Join(workDir, file.Name)
		// 安全检查：确保解压路径在工作目录内
		absWorkDir, _ := filepath.Abs(workDir)
		absPath, _ := filepath.Abs(path)
		if !strings.HasPrefix(absPath, absWorkDir) {
			log.Printf("解压路径不安全，跳过: %s", path)
			rc.Close()
			continue
		}
		if file.FileInfo().IsDir() {
			os.MkdirAll(path, os.ModePerm)
			rc.Close()
		} else {
			// 确保父目录存在
			os.MkdirAll(filepath.Dir(path), os.ModePerm)
			f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode())
			if err != nil {
				rc.Close()
				log.Printf("创建解压文件失败: %v", err)
				return err
			}
			_, err = io.Copy(f, rc)
			f.Close()
			rc.Close()
			if err != nil {
				log.Printf("写入解压文件失败: %v", err)
				return err
			}
		}
	}
	log.Printf("解压zip完成: %s -> %s", zipFile, workDir)
	return nil
}
func Untar(tarFile string, task_uuid string, workDir string) error {
	// tarFile 是文件名，完整路径在workDir中
	tarFilePath := filepath.Join(workDir, tarFile)
	f, err := os.Open(tarFilePath)
	if err != nil {
		log.Printf("解压tar失败: %v, 文件路径: %s", err, tarFilePath)
		return err
	}
	defer f.Close()
	err = os.MkdirAll(workDir, os.ModePerm)
	if err != nil {
		log.Printf("创建解压目录失败: %v", err)
		return err
	}
	tr := tar.NewReader(f)
	for {
		header, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Printf("读取tar头失败: %v", err)
			return err
		}
		path := filepath.Join(workDir, header.Name)
		// 安全检查：确保解压路径在工作目录内
		absWorkDir, _ := filepath.Abs(workDir)
		absPath, _ := filepath.Abs(path)
		if !strings.HasPrefix(absPath, absWorkDir) {
			log.Printf("解压路径不安全，跳过: %s", path)
			continue
		}
		if header.Typeflag == tar.TypeDir {
			os.MkdirAll(path, os.ModePerm)
		} else {
			// 确保父目录存在
			os.MkdirAll(filepath.Dir(path), os.ModePerm)
			f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, header.FileInfo().Mode())
			if err != nil {
				log.Printf("创建解压文件失败: %v", err)
				return err
			}
			_, err = io.Copy(f, tr)
			f.Close()
			if err != nil {
				log.Printf("写入解压文件失败: %v", err)
				return err
			}
		}
	}
	log.Printf("解压tar完成: %s -> %s", tarFile, workDir)
	return nil
}

// Ungzip 解压gz文件
func Ungzip(gzFile string, task_uuid string, workDir string) error {
	gzFilePath := filepath.Join(workDir, gzFile)
	f, err := os.Open(gzFilePath)
	if err != nil {
		log.Printf("解压gz失败: %v, 文件路径: %s", err, gzFilePath)
		return err
	}
	defer f.Close()

	gr, err := gzip.NewReader(f)
	if err != nil {
		log.Printf("创建gz读取器失败: %v", err)
		return err
	}
	defer gr.Close()

	// 去除.gz后缀作为输出文件名
	outputName := strings.TrimSuffix(gzFile, ".gz")
	outputPath := filepath.Join(workDir, outputName)

	// 确保父目录存在
	os.MkdirAll(filepath.Dir(outputPath), os.ModePerm)

	out, err := os.Create(outputPath)
	if err != nil {
		log.Printf("创建输出文件失败: %v", err)
		return err
	}
	defer out.Close()

	_, err = io.Copy(out, gr)
	if err != nil {
		log.Printf("解压gz文件失败: %v", err)
		return err
	}

	log.Printf("解压gz完成: %s -> %s", gzFile, outputPath)
	return nil
}

// UntarGz 解压tar.gz文件
func UntarGz(tarGzFile string, task_uuid string, workDir string) error {
	tarGzFilePath := filepath.Join(workDir, tarGzFile)
	f, err := os.Open(tarGzFilePath)
	if err != nil {
		log.Printf("解压tar.gz失败: %v, 文件路径: %s", err, tarGzFilePath)
		return err
	}
	defer f.Close()

	// 创建gzip读取器
	gr, err := gzip.NewReader(f)
	if err != nil {
		log.Printf("创建gz读取器失败: %v", err)
		return err
	}
	defer gr.Close()

	// 从gzip读取器创建tar读取器
	tr := tar.NewReader(gr)

	err = os.MkdirAll(workDir, os.ModePerm)
	if err != nil {
		log.Printf("创建解压目录失败: %v", err)
		return err
	}

	for {
		header, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Printf("读取tar头失败: %v", err)
			return err
		}
		path := filepath.Join(workDir, header.Name)
		// 安全检查：确保解压路径在工作目录内
		absWorkDir, _ := filepath.Abs(workDir)
		absPath, _ := filepath.Abs(path)
		if !strings.HasPrefix(absPath, absWorkDir) {
			log.Printf("解压路径不安全，跳过: %s", path)
			continue
		}
		if header.Typeflag == tar.TypeDir {
			os.MkdirAll(path, os.ModePerm)
		} else {
			// 确保父目录存在
			os.MkdirAll(filepath.Dir(path), os.ModePerm)
			f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, header.FileInfo().Mode())
			if err != nil {
				log.Printf("创建解压文件失败: %v", err)
				return err
			}
			_, err = io.Copy(f, tr)
			f.Close()
			if err != nil {
				log.Printf("写入解压文件失败: %v", err)
				return err
			}
		}
	}
	log.Printf("解压tar.gz完成: %s -> %s", tarGzFile, workDir)
	return nil
}
