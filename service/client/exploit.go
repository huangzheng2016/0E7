package client

import (
	"0E7/service/config"
	"0E7/utils"
	"archive/tar"
	"archive/zip"
	"bufio"
	"bytes"
	"context"
	"crypto/tls"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/traefik/yaegi/interp"
	"github.com/traefik/yaegi/stdlib"
	"golang.org/x/sync/semaphore"
)

var (
	workerSemaphore *semaphore.Weighted
	jobsChan        = make(chan bool, 100)
	client          = &http.Client{
		Timeout: time.Duration(config.Global_timeout_http) * time.Second,
		Transport: &http.Transport{
			TLSClientConfig:       &tls.Config{InsecureSkipVerify: true},
			MaxIdleConns:          100,              // 最大空闲连接数
			MaxIdleConnsPerHost:   20,               // 每个主机的最大空闲连接数
			IdleConnTimeout:       90 * time.Second, // 空闲连接超时时间
			DisableKeepAlives:     false,            // 启用keep-alive
			DisableCompression:    false,            // 禁用压缩以减少CPU使用
			ResponseHeaderTimeout: 30 * time.Second, // 响应头超时
		},
	}
)

func exploit() {
	defer func() {
		if err := recover(); err != nil {
			log.Println("Exploit error: ", err)
		}
	}()

	values := url.Values{}
	values.Set("client_id", fmt.Sprintf("%d", config.Client_id))
	values.Set("platform", runtime.GOOS)
	values.Set("arch", runtime.GOARCH)
	requestBody := bytes.NewBufferString(values.Encode())
	request, err := http.NewRequest("POST", config.Server_url+"/api/exploit", requestBody)
	if err != nil {
		log.Println(err)
		return
	}
	request.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	response, err := client.Do(request)
	if err != nil {
		log.Println(err)
		return
	}
	defer response.Body.Close() // 确保关闭响应体
	if response.StatusCode == 200 {
		jobsChan <- true
		var result map[string]interface{}
		err = json.NewDecoder(response.Body).Decode(&result)
		if err != nil {
			log.Println(err)
		}

		task_uuid := uuid.New().String()

		exploit_name := result["name"].(string)
		exploit_id_float := result["id"].(float64)
		exploit_id := int(exploit_id_float)
		client_id := config.Client_id

		log.Printf("开始执行任务 %s (ID: %d)", exploit_name, exploit_id)
		folder := "exploit/" + task_uuid + "/"
		filename := result["filename"].(string)
		command := result["command"].(string)
		environment := result["environment"].(string)
		argv := result["argv"].(string)
		flag := result["flag"].(string)
		timeoutStr := result["timeout"].(string)
		team := result["team"].(string)
		var timeout int
		if timeoutStr != "" {
			timeout, err = strconv.Atoi(timeoutStr)
			if err != nil {
				timeout = 30 // 默认30秒超时
			}
		} else {
			timeout = 30 // 默认30秒超时
		}
		output_id := ""
		exploit_output := ""

		defer func() {
			os.RemoveAll(folder)
		}()

		var code, fileType string
		match := regexp.MustCompile(`^data:(code\/(?:python2|python3|golang|bash));base64,(.*)$`).FindStringSubmatch(filename)
		if match != nil {
			_, err := os.Stat(folder)
			if err != nil {
				err = os.MkdirAll(folder, os.ModePerm)
				if err != nil {
					log.Println("IO error:", err)
					return
				}
			}
			fileType = match[1]
			data := match[2]
			switch fileType {
			case "code/python2", "code/python3":
				filename = fmt.Sprintf("%d.py", exploit_id)
			case "code/golang":
				filename = fmt.Sprintf("%d.go", exploit_id)
			case "code/bash":
				filename = fmt.Sprintf("%d.sh", exploit_id)
			}
			code_decode, err := base64.StdEncoding.DecodeString(data)
			if err != nil {
				log.Println("Base64 decode error:", err)
				return
			}
			err = ioutil.WriteFile(folder+"/"+filename, code_decode, 0644)
			if err != nil {
				log.Println("IO error:", err)
				return
			}
			code = string(code_decode)

		} else {
			err := exploit_download(fmt.Sprintf("%d", exploit_id), task_uuid, filename)
			if err != nil {
				log.Println("Download error:", err)
				return
			}
		}

		lowerStr := strings.ToLower(environment)
		_, isPipreqs := set_pipreqs.Load(fmt.Sprintf("%d", exploit_id))
		if (strings.Contains(lowerStr, "auto_pipreqs") && !isPipreqs) || strings.Contains(lowerStr, "force_pipreqs") {
			err := auto_pipreqs(folder, fileType)
			if err != nil {
				exploit_output += err.Error() + "\n"
			}
		}

		ctx_command, cancel_comand := context.WithTimeout(context.Background(), time.Duration(timeout)*time.Second)
		defer cancel_comand()

		var cmd *exec.Cmd

		var goi *interp.Interpreter
		if command == "" && strings.HasSuffix(filename, ".py") {
			args := []string{"-u", filename}
			args = append(args, splitArgs(argv)...)
			switch fileType {
			case "code/python2":
				cmd = exec.CommandContext(ctx_command, "python2", args...)
			case "code/python3":
				cmd = exec.CommandContext(ctx_command, "python3", args...)
			}
		} else if command == "" && strings.HasSuffix(filename, ".sh") {
			// 设置bash脚本执行权限
			err := os.Chmod(folder+"/"+filename, 0755)
			if err != nil {
				log.Println("设置执行权限失败:", err)
				return
			}
			args := []string{filename}
			args = append(args, splitArgs(argv)...)
			cmd = exec.CommandContext(ctx_command, "bash", args...)
		} else if command != "" {
			if runtime.GOOS == "windows" {
				args := []string{"/C", command}
				args = append(args, splitArgs(argv)...)
				cmd = exec.CommandContext(ctx_command, "cmd.exe", args...)
			} else {
				args := []string{"-c", command}
				args = append(args, splitArgs(argv)...)
				cmd = exec.CommandContext(ctx_command, "/bin/sh", args...)
			}
		} else if fileType != "" {
			cmd = exec.CommandContext(ctx_command, "")
		} else {
			return
		}
		wddir, err := os.Getwd()
		if err != nil {
			log.Println("无法获取当前目录：", err)
			return
		}
		cmd.WaitDelay = time.Duration(timeout) * time.Second
		cmd.Dir = wddir + "/" + folder
		envVars := strings.Split(environment, ";")
		cmd.Env = append(os.Environ(), envVars...)
		stdout, err := cmd.StdoutPipe()
		var stdeer bytes.Buffer
		cmd.Stderr = &stdeer
		readout := bufio.NewReader(stdout)
		if err != nil {
			log.Println("Pipe Error:", err)
			return
		}
		status := "RUNNING"

		var goibuf bytes.Buffer
		var wg sync.WaitGroup
		var goierr error

		if fileType == "code/golang" {
			goi = interp.New(interp.Options{Stdout: &goibuf, Stderr: &stdeer, Args: splitArgs(argv), Env: cmd.Env})
			goi.Use(stdlib.Symbols)
			md5 := utils.GetMd5FromString(argv + "_" + code)
			var program *interp.Program
			if value, ok := programs.Load(md5); !ok {
				program, err = goi.Compile(code)
				if err != nil {
					log.Println("Compile error:", err.Error())
					return
				}
				programs.Store(md5, program)
			} else {
				program = value.(*interp.Program)
			}
			readout = bufio.NewReader(&goibuf)
			wg.Add(1)
			go func() {
				defer wg.Done()
				_, goierr = goi.ExecuteWithContext(ctx_command, program)
				if goierr != nil {
					log.Println("Runtime error:", goierr.Error())
					return
				}
			}()
		} else {
			err = cmd.Start()
			if err != nil {
				log.Println(err)
				return
			}
		}
		ctx, cancel := context.WithCancel(context.Background())
		go post_output_scanner(readout, &exploit_output)
		var wg_output sync.WaitGroup
		wg_output.Add(1)
		go post_output_status(&output_id, exploit_id, client_id, status, ctx, &wg_output, &exploit_output)

		// 等待命令完成或超时
		done := make(chan error, 1)
		go func() {
			if fileType == "code/golang" {
				wg.Wait()
				done <- goierr
			} else {
				done <- cmd.Wait()
			}
		}()

		select {
		case err := <-done:
			// 命令正常完成
			if err != nil {
				// 检查是否是超时错误
				if err == context.DeadlineExceeded {
					status = "TIMEOUT"
					log.Printf("任务 %s (ID: %d) 执行超时 (超过 %d 秒)", exploit_name, exploit_id, timeout)
				} else {
					status = "ERROR"
					log.Printf("任务 %s (ID: %d) 执行失败: %v", exploit_name, exploit_id, err)
					log.Println("错误输出:\n" + stdeer.String())
				}
			} else {
				status = "SUCCESS"
				set_pipreqs.Store(fmt.Sprintf("%d", exploit_id), true)
				log.Printf("任务 %s (ID: %d) 执行成功", exploit_name, exploit_id)
			}
		case <-ctx_command.Done():
			// 超时发生
			status = "TIMEOUT"
			log.Printf("任务 %s (ID: %d) 执行超时 (超过 %d 秒)", exploit_name, exploit_id, timeout)

			// 强制终止进程
			if cmd.Process != nil {
				cmd.Process.Kill()
			}
		}

		// 先停止后台状态更新
		cancel()
		wg_output.Wait()

		// 然后发送最终状态更新
		output_id = post_output(output_id, exploit_id, client_id, "", status)

		post_output_scanner(readout, &exploit_output)

		erroutput := stdeer.String()
		if erroutput != "" {
			if status == "TIMEOUT" {
				erroutput = "\nTIMEOUT:\n" + erroutput
			} else {
				erroutput = "\nERROR:\n" + erroutput
			}
		} else if status == "TIMEOUT" {
			erroutput = "\nTIMEOUT: " + strconv.Itoa(timeout) + " seconds"
		}

		output_id = post_output(output_id, exploit_id, client_id, exploit_output+erroutput, status)

		log.Println("RUN " + exploit_name + " OUTPUT:\n" + exploit_output)

		if flag != "" {
			regexpObj := regexp.MustCompile(flag)
			matches := regexpObj.FindAllString(exploit_output, -1)
			for _, match := range matches {
				post_flag(exploit_id, team, match)
			}
		}
	}
}

func splitArgs(input string) []string {
	var args []string
	start := -1
	inQuote := false

	for i, char := range input {
		if char == '"' {
			inQuote = !inQuote
		} else if char == ' ' && !inQuote {
			if start >= 0 {
				if input[start] == '"' && input[i-1] == '"' {
					args = append(args, input[start+1:i-1])
				} else {
					args = append(args, input[start:i])
				}
				start = -1
			}
			continue
		}

		if start < 0 {
			start = i
		}
	}

	if start >= 0 {
		if input[start] == '"' && input[len(input)-1] == '"' {
			args = append(args, input[start+1:len(input)-1])
		} else {
			args = append(args, input[start:])
		}
	}

	return args
}

func post_output_scanner(readout *bufio.Reader, exploit_output *string) {
	defer func() {
		if err := recover(); err != nil {
			log.Println("Post output scanner Error:", err)
		}
	}()
	outputBytes := make([]byte, 200)
	for {
		n, err := readout.Read(outputBytes)
		if err != nil {
			if errors.Is(err, io.EOF) || errors.Is(err, fs.ErrClosed) {
				return
			}
			log.Println(err)
			*exploit_output += err.Error()
			return
		}
		output := string(outputBytes[:n])
		*exploit_output += output
	}
}
func post_output_status(output_id *string, exploit_id int, client_id int, status string, ctx context.Context, wg_output *sync.WaitGroup, exploit_output *string) {
	defer func() {
		if err := recover(); err != nil {
			log.Println("Post output Status Error:", err)
		}
		wg_output.Done() // 确保在函数退出时调用Done()
	}()
	run := false
	old_len := 0
	for {
		select {
		case <-ctx.Done():
			return
		case <-time.After(5 * time.Second):
			new_len := len(*exploit_output)
			*output_id = post_output(*output_id, exploit_id, client_id, (*exploit_output)[old_len:new_len], status)
			old_len = new_len
			if !run {
				run = true
			}
		}
	}
}

func post_output(id string, exploit_id int, client_id int, output string, status string) string {
	values := url.Values{}
	values.Set("id", id)
	values.Set("exploit_id", fmt.Sprintf("%d", exploit_id))
	values.Set("client_id", fmt.Sprintf("%d", client_id))
	values.Set("output", output)
	values.Set("status", status)

	requestBody := bytes.NewBufferString(values.Encode())
	request, err := http.NewRequest("POST", config.Server_url+"/api/exploit_output", requestBody)
	if err != nil {
		log.Println(err)
		return ""
	}
	request.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	response, err := client.Do(request)
	if err != nil {
		log.Println(err)
		return ""
	}
	defer response.Body.Close() // 确保关闭响应体
	if response.StatusCode == http.StatusOK {
		//log.Printf("Post success")
		var result map[string]interface{}
		err = json.NewDecoder(response.Body).Decode(&result)
		if err != nil {
			log.Println(err)
		}
		return result["id"].(string)
	} else {
		log.Printf("Postfail with %d", response.StatusCode)
		return ""
	}
}

func post_flag(exploit_id int, team string, exploit_flag string) {
	values := url.Values{}
	values.Set("exploit_id", fmt.Sprintf("%d", exploit_id))
	values.Set("flag", exploit_flag)
	values.Set("team", team)
	requestBody := bytes.NewBufferString(values.Encode())
	request, err := http.NewRequest("POST", config.Server_url+"/api/flag", requestBody)
	if err != nil {
		log.Println(err)
	}
	request.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	response, err := client.Do(request)
	if err != nil {
		log.Println(err)
		return
	}
	defer response.Body.Close() // 确保关闭响应体
	switch response.StatusCode {
	case http.StatusOK:
		log.Printf("Post %s success", exploit_flag)
	case http.StatusAccepted:
		log.Printf("Post %s skipped", exploit_flag)
	default:
		respBody, err := io.ReadAll(response.Body)
		if err != nil {
			log.Println(err)
		}
		log.Printf("Post %s fail with %d: %s", exploit_flag, response.StatusCode, string(respBody))
	}
}

func auto_pipreqs(filepath string, fileType string) error {
	var pipName string
	switch fileType {
	case "code/python2":
		pipName = "pip2"
	case "code/python3":
		pipName = "pip3"
	default:
		return fmt.Errorf("not need auto pipreqs for file type %s", fileType)
	}
	cmd := exec.Command(pipName, "install", "pipreqs", "-i", config.Client_pypi, "--break")
	err := cmd.Start()
	if err != nil {
		log.Println("Auto pipreqs:", err.Error())
		return err
	}
	if err = cmd.Wait(); err != nil {
		log.Println("Auto pipreqs:", err.Error())
		return err
	}

	cmd = exec.Command("pipreqs", "--encoding=utf-8", filepath, "--savepath", filepath+"auto_pipreqs.txt", "--force", "--mode", "no-pin")

	err = cmd.Start()
	if err != nil {
		log.Println(err.Error())
		return err
	}
	if err = cmd.Wait(); err != nil {
		log.Println("Auto pipreqs:", err.Error())
		return err
	}

	cmd = exec.Command(pipName, "install", "-r", filepath+"auto_pipreqs.txt", "-i", config.Client_pypi, "--break")
	err = cmd.Start()
	if err != nil {
		log.Println(err.Error())
		return err
	}
	if err = cmd.Wait(); err != nil {
		log.Println("Auto pipreqs:", err.Error())
		return err
	}
	return nil
}

/*
	func setenv(environment string) {
		vars := strings.Split(environment, ";")
		for _, v := range vars {
			kv := strings.SplitN(v, "=", 2)
			if len(kv) == 2 {
				key := kv[0]
				value := kv[1]
				os.Setenv(key, value)
			}
		}
	}
*/
func exploit_download(exploit_name string, task_uuid string, filename string) error {
	if filename == "" {
		return nil
	}
	values := url.Values{}
	values.Set("id", exploit_name)
	values.Set("filename", filename)
	folder := "exploit/" + task_uuid
	requestBody := bytes.NewBufferString(values.Encode())
	request, err := http.NewRequest("POST", config.Server_url+"/api/exploit_download", requestBody)
	if err != nil {
		return err
	}
	request.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	response, err := client.Do(request)
	if err != nil {
		return err
	}
	defer response.Body.Close() // 确保关闭响应体
	err = os.MkdirAll(folder, os.ModePerm)
	if err != nil {
		return err
	}
	out, err := os.Create(folder + "/" + filename)
	if err != nil {
		return err
	}
	defer out.Close()
	_, err = io.Copy(out, response.Body)
	if err != nil {
		return err
	}
	if strings.HasSuffix(filename, ".zip") {
		Unzip(filename, exploit_name)
	} else if strings.HasSuffix(filename, ".tar") {
		Untar(filename, exploit_name)
	}
	return nil
}
func Unzip(zipFile string, exploit_name string) error {
	destDir := "exploit/" + exploit_name + "/"
	zipFile = destDir + zipFile
	r, err := zip.OpenReader(zipFile)
	if err != nil {
		log.Println(err)
		return err
	}
	defer r.Close()
	for _, file := range r.File {
		rc, err := file.Open()
		if err != nil {
			log.Println(err)
			return err
		}
		defer rc.Close()
		path := filepath.Join(destDir, file.Name)
		if file.FileInfo().IsDir() {
			os.MkdirAll(path, os.ModePerm)
		} else {
			f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode())
			if err != nil {
				log.Println(err)
				return err
			}
			defer f.Close()
			_, err = io.Copy(f, rc)
			if err != nil {
				log.Println(err)
				return err
			}
		}
	}
	log.Println("解压zip完成")
	return nil
}
func Untar(tarFile string, exploit_name string) error {
	destDir := "exploit/" + exploit_name + "/"
	tarFile = destDir + tarFile
	f, err := os.Open(tarFile)
	if err != nil {
		log.Println(err)
		return err
	}
	defer f.Close()
	err = os.MkdirAll(destDir, os.ModePerm)
	if err != nil {
		log.Println(err)
		return err
	}
	tr := tar.NewReader(f)
	for {
		header, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Println(err)
			return err
		}
		path := filepath.Join(destDir, header.Name)
		if header.Typeflag == tar.TypeDir {
			os.MkdirAll(path, os.ModePerm)
		} else {
			f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, header.FileInfo().Mode())
			if err != nil {
				log.Println(err)
				return err
			}
			defer f.Close()
			_, err = io.Copy(f, tr)
			if err != nil {
				log.Println(err)
				return err
			}
		}
	}
	log.Println("解压tar完成")
	return nil
}
