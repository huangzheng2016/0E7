package route

import (
	"0E7/service/config"
	"0E7/service/database"
	"crypto/md5"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"math/rand/v2"
	"os"
	"regexp"
	"strconv"
	"strings"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

type Bucket struct {
	Team  string `json:"team"`
	Value string `json:"value"`
}

func exploit(c *gin.Context) {
	exploit_mutex.Lock()
	defer exploit_mutex.Unlock()

	client_id_str := c.Query("client_id")
	platform := c.Query("platform")
	arch := c.Query("arch")

	var exploit database.Exploit
	err := config.Db.Where("(filter = '' OR filter LIKE ?) AND (platform = '' OR platform LIKE ?) AND (arch = '' OR arch LIKE ?) AND (times <= -2 OR times >= 1) AND is_deleted = ?",
		"%"+client_id_str+"%", "%"+platform+"%", "%"+arch+"%", false).
		Order("RANDOM()").
		First(&exploit).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(202, gin.H{
				"message":     "no task",
				"error":       "",
				"name":        "",
				"filename":    "",
				"environment": "",
				"command":     "",
				"argv":        "",
				"flag":        "",
				"team":        "",
				"timeout":     "",
			})
			return
		} else {
			c.JSON(400, gin.H{
				"message":     "fail",
				"error":       err.Error(),
				"name":        "",
				"filename":    "",
				"environment": "",
				"command":     "",
				"argv":        "",
				"flag":        "",
				"team":        "",
				"timeout":     "",
			})
			return
		}
	}
	if exploit.Name == "" {
		c.JSON(202, gin.H{
			"message":     "no task",
			"error":       "",
			"name":        "",
			"filename":    "",
			"environment": "",
			"command":     "",
			"argv":        "",
			"flag":        "",
			"team":        "",
			"timeout":     "",
		})
	} else {
		costTime := false

		reg := regexp.MustCompile(`\{[^}]+\}`)
		matches := reg.FindAllString(exploit.Argv, -1)
		if len(matches) == 0 {
			costTime = true
		}
		for _, match := range matches {
			action := match[1 : len(match)-1]
			if strings.HasPrefix(action, "ipbucket_") || strings.HasPrefix(action, "cache_") {
				var backet []Bucket
				if value, ok := exploit_bucket.Load(exploit.ID); !ok {
					var actionRecord database.Action
					err = config.Db.Where("name = ? AND is_deleted = ?", action, false).First(&actionRecord).Error
					if err != nil {
						actionRecord.Output = ""
					}
					err = json.Unmarshal([]byte(actionRecord.Output), &backet)
					if err != nil {
						lines := strings.Split(actionRecord.Output, "\n")
						for _, line := range lines {
							line = strings.TrimSpace(line)
							if line == "" {
								continue
							}
							backet = append(backet, Bucket{
								Team:  line,
								Value: line,
							})
						}
					}
					if strings.HasPrefix(action, "ipbucket_") {
						rand.Shuffle(len(backet), func(i, j int) {
							backet[i], backet[j] = backet[j], backet[i]
						})
					}
				} else {
					backet = value.([]Bucket)
				}
				if len(backet) == 0 {
					backet = []Bucket{
						{
							Team:  "NOTHING_IN_BUCKET",
							Value: "NOTHING_IN_BUCKET",
						},
					}
				}
				first := backet[0]
				backet = backet[1:]
				if len(backet) == 0 {
					exploit_bucket.Delete(exploit.ID)
					costTime = true
				} else {
					exploit_bucket.Store(exploit.ID, backet)
				}
				exploit.Argv = strings.Replace(exploit.Argv, match, first.Value, 1)
				exploit.Team = first.Team
			} else {
				var actionRecord database.Action
				err = config.Db.Where("name = ? AND is_deleted = ?", action, false).First(&actionRecord).Error
				if err == nil {
					exploit.Argv = strings.Replace(exploit.Argv, match, actionRecord.Output, 1)
				}
				costTime = true
			}
		}
		if exploit.Flag == "" {
			exploit.Flag = config.Server_flag
		}

		times, _ := strconv.Atoi(exploit.Times)
		if times >= 0 && costTime {
			times -= 1
			err = config.Db.Model(&exploit).Where("id = ?", exploit.ID).Update("times", fmt.Sprintf("%d", times)).Error
			if err != nil {
				c.JSON(400, gin.H{
					"message":     "fail",
					"error":       err.Error(),
					"name":        "",
					"filename":    "",
					"environment": "",
					"command":     "",
					"argv":        "",
					"flag":        "",
					"team":        "",
					"timeout":     "",
				})
				c.Abort()
			}
		}

		log.Printf("任务 %s 已分配给客户端 %s", exploit.Name, client_id_str)

		c.JSON(200, gin.H{
			"message":     "success",
			"error":       "",
			"id":          exploit.ID,
			"name":        exploit.Name,
			"filename":    exploit.Filename,
			"environment": exploit.Environment,
			"command":     exploit.Command,
			"argv":        exploit.Argv,
			"flag":        config.Server_flag,
			"flag_regex":  exploit.Flag,
			"team":        exploit.Team,
			"timeout":     exploit.Timeout,
		})
	}
}

// calculateFileMD5 计算文件的MD5值
func calculateFileMD5(filePath string) (string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return "", err
	}
	defer file.Close()

	hash := md5.New()
	if _, err := io.Copy(hash, file); err != nil {
		return "", err
	}

	return hex.EncodeToString(hash.Sum(nil)), nil
}

func exploit_download(c *gin.Context) {
	exploit_id := c.Query("id")
	filename := c.Query("filename")
	filePath := "upload/" + exploit_id + "/" + filename
	_, err := os.Stat(filePath)
	if err != nil {
		c.JSON(404, gin.H{
			"message": "fail",
			"error":   err.Error(),
		})
		c.Abort()
		return
	}

	// 计算文件MD5并添加到响应头
	fileMD5, err := calculateFileMD5(filePath)
	if err == nil {
		c.Header("X-File-MD5", fileMD5)
	}

	c.Header("Content-Disposition", "attachment; filename="+filename)
	c.Header("Content-Type", "application/octet-stream")

	// 如果是HEAD请求，只返回响应头，不返回文件内容
	if c.Request.Method == "HEAD" {
		fileInfo, _ := os.Stat(filePath)
		if fileInfo != nil {
			c.Header("Content-Length", fmt.Sprintf("%d", fileInfo.Size()))
		}
		c.Status(200)
		return
	}

	c.File(filePath)
}
func exploit_output(c *gin.Context) {
	var err error
	id := c.PostForm("id")
	exploit_id_str := c.PostForm("exploit_id")
	client_id_str := c.PostForm("client_id")
	output := c.PostForm("output")
	status := c.PostForm("status")

	// 转换exploit_id为int
	exploit_id, err := strconv.Atoi(exploit_id_str)
	if err != nil {
		c.JSON(400, gin.H{
			"message": "fail",
			"error":   "invalid exploit_id: " + err.Error(),
			"id":      "",
		})
		log.Println("Invalid exploit_id:", err)
		return
	}

	// 转换client_id为int
	client_id, err := strconv.Atoi(client_id_str)
	if err != nil {
		c.JSON(400, gin.H{
			"message": "fail",
			"error":   "invalid client_id: " + err.Error(),
			"id":      "",
		})
		log.Println("Invalid client_id:", err)
		return
	}

	if id == "" {
		// 获取exploit名称用于日志
		var exploit database.Exploit
		config.Db.First(&exploit, exploit_id)

		log.Printf("开始执行任务 %s (ID: %d)", exploit.Name, exploit_id)

		exploitOutput := database.ExploitOutput{
			ExploitId: exploit_id,
			ClientId:  client_id,
			Team:      exploit.Team,
			Output:    output,
			Status:    status,
		}
		err := config.Db.Create(&exploitOutput).Error
		if err != nil {
			c.JSON(400, gin.H{
				"message": "fail",
				"error":   err.Error(),
				"id":      "",
			})
			log.Println(err)
			return
		}
		c.JSON(200, gin.H{
			"message": "success",
			"error":   "",
			"id":      fmt.Sprintf("%d", exploitOutput.ID),
		})
	} else {
		var exploitOutput database.ExploitOutput
		err = config.Db.First(&exploitOutput, id).Error
		if err != nil {
			c.JSON(400, gin.H{
				"message": "fail",
				"error":   err.Error(),
				"id":      "",
			})
			log.Println(err)
			return
		}

		if status == "RUNNING" {
			exploitOutput.Output += output
		} else {
			exploitOutput.Output = output
			// 任务完成时记录日志
			var exploit database.Exploit
			config.Db.First(&exploit, exploitOutput.ExploitId)
			log.Printf("任务 %s (ID: %d) 执行%s", exploit.Name, exploitOutput.ExploitId, status)
		}
		exploitOutput.Status = status

		err = config.Db.Save(&exploitOutput).Error
		if err != nil {
			c.JSON(400, gin.H{
				"message": "fail",
				"error":   err.Error(),
				"id":      "",
			})
			log.Println(err)
			return
		}
		c.JSON(200, gin.H{
			"message": "update",
			"error":   "",
			"id":      id,
		})
	}
}
